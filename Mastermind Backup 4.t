/*
 File: Mastermind.t
 Name: ZiCheng Huang
 Class: ICS2O3
 Date: January 13, 2017
 Description: The game of mastermind. In this game, a code is randomly generated or it can be set by another player.
 The point of the game is to correctly guess the sequence of the code in a set amount of guesses. If you
 do, you win. Otherwise, you lose, or the other player wins. To help you, after every guess the computer
 will return the number of correct colors in the right position and also the number of correct colors in
 the wrong position.

 Extensions:
 -(Line 387)      Allow user to set the number of guesses allowed.
 -(Line 440)      Have a two-player version in which the secret code is entered by a player instead of randomly generated by the program. Code entered by the player must be validated.
 -(Line 723)      Restart the game without restarting the program.
 -(Line 332, 665) Have graphics on the welcome and outcome screens.
 -(Line 564, 629) Guesses and feedback are displayed graphically.
 -(Line 397)      User can set the length of the code.
 -(Line 552)      Full graphical user interface: guesses are made using mouse click, guesses and feedbackare displayed graphically.
 */

const ENTER_INSTRUCTIONS := 1
const ENTER_STARTGAMEONEPLAYER := 2
const ENTER_STARTGAMETWOPLAYER := 3
const ENTER_OPTIONS := 4

const RESTART := 1
const END_GAME := 2

const MAXROW := 10

% Procedure for instructions
procedure instructions
    put "Rules of the game: \n"
    put "1 player:"
    put "The computer randomly generates a code, and you have to solve it in a certain number of guesses."
    put "In each guess, enter the numbers that you think is correct, and the computer will give you feedback based on your guess."
    put "It will tell you the number of correct numbers in the right position."
    put "It will also tell you the number of correct numbers in the wrong position."
    put "You win if you guess the correct sequence of the code within the guesses allocated, and you will lose if you don't.\n"
    put "2 players:"
    put "The rules are the same, but the second player will put in his/her sequence instead of randomly generating it."
    put "Player 1 wins if he/she guesses the code within the guesses allocated, and Player 2 wins if he/she doesn't.\n"
    put "Press any key to continue!"
end instructions

% Menu variables


var chars : array char of boolean

var backToMenu : boolean := false
var menuInput : int := 1
var endInput : int := 1
var inputAnyKey : string % This is useless for any of the calculations

var youWin : boolean := false
var endGame : boolean := false

var loadXOne : int := 300
var loadYOne : int := 350
var loadXTwo : int := 301
var loadYTwo : int := 450

var twoPCircX, twoPCircY : int
var invalidInput : boolean := false
var answerTempStr : string

% Gameplay variables (Do not reset!)
const MINCOLORNUM := 1
const MAXCOLORNUM := 8
var colorCharsList : array 1 .. MAXCOLORNUM of string := init ("bl", "gr", "rd", "pp", "br", "yl", "mg", "ga")

var colorTemp : int

var colorCirc : array 1 .. 8 of int := init (1, 2, 4, 5, 185, 14, 13, 15)

var twoPlayer : boolean := false

var codeLength : int := 4 %User input

var guessNum : int := 1
var guessMaxNum : int := 12 %User input

% Gameplay variables (Reset every guess)
var guessRightSoFar : boolean := true

var correctRightPosNum : int := 0
var correctWrongPosNum : int := 0

% Fonts and graphical
var fontTitle : int
var fontSub1 : int
var fontSub2 : int
var fontArrow : int
var fontEnd1 : int
var fontEnd2 : int
var fontEnd3 : int
var fontGuess : int

fontTitle := Font.New ("sans serif:72:bold")
fontArrow := Font.New ("ar destine:40:bold")
fontSub1 := Font.New ("Palatino:40:bold")
fontSub2 := Font.New ("Palatino:30:bold")
fontEnd1 := Font.New ("sans serif:50:bold")
fontEnd2 := Font.New ("sans serif:40:bold")
fontEnd3 := Font.New ("sans serif:30:bold")
fontGuess := Font.New ("sans serif:30:bold")

var drawLineX1, drawLineX2 : int
var drawLineY1, drawLineY2 : int

% Procedure for menu screen
procedure menu
    Font.Draw ("MASTERMIND", 190, 500, fontTitle, 7)
    Font.Draw ("INSTRUCTIONS", 350, 400, fontSub2, 7)
    Font.Draw ("ONE PLAYER", 370, 300, fontSub2, 7)
    Font.Draw ("TWO PLAYER", 367, 200, fontSub2, 7)
    Font.Draw ("OPTIONS", 400, 100, fontSub2, 7)
end menu

% Procedure for end screen
procedure endScreen
    Font.Draw ("MASTERMIND", 190, 500, fontTitle, 7)
    Font.Draw ("RESTART", 400, 320, fontSub2, 7)
    Font.Draw ("END GAME", 390, 220, fontSub2, 7)
end endScreen

% Procedure for menu arrow
procedure menuArrow
    if (menuInput = 1) then
	cls
	menu
	Font.Draw (">>>", 150, 400, fontArrow, 7)
    elsif (menuInput = 2) then
	cls
	menu
	Font.Draw (">>>", 150, 300, fontArrow, 7)
    elsif (menuInput = 3) then
	cls
	menu
	Font.Draw (">>>", 150, 200, fontArrow, 7)
    elsif (menuInput = 4) then
	cls
	menu
	Font.Draw (">>>", 150, 100, fontArrow, 7)
    end if
end menuArrow

% Procedure for end arrow
procedure endArrow
    if (endInput = 1) then
	cls
	endScreen
	Font.Draw (">>>", 150, 320, fontArrow, 7)
    elsif (endInput = 2) then
	cls
	endScreen
	Font.Draw (">>>", 150, 220, fontArrow, 7)
    end if
end endArrow

% Ending screen variables
var codeEndX : int := 510
var endBackScreenColor : int
var endTextColor : int

% Graphics for circles at the top
var topCircX : int := 325
var topCircY : int := 595

% Graphics for circles in main screen(displays guesses)
var guessCircX : int
var guessCircY : int := 495

var currentCircle : int := 1

% Displaying guess number
var guessNumGraphicX : int := 658
var guessNumGraphicY : int := 478
var guessValue : string
var guessValueInt : int

% Displaying correct position and color
var rightCircX : int := 712
var rightCircY : int := 557 - guessNum * 50
var wrongCircX : int := 712
var wrongCircY : int := 532 - guessNum * 50

var currentRightCirc : int := 2
var currentWrongCirc : int := 2

% Mouse stuff
var x, y, buttonnumber, buttonupdown, buttons : int

% Function for getting mouse input guess
function getGuess (x : int, y : int) : int
    for i : 1 .. 8
	if (x > 250 + i * 50 and x < 300 + i * 50 and y > 570 and y < 620) then
	    result i
	end if
    end for
    result 0
end getGuess

% Function for getting circle colour
function getColor (colorTemp : int) : int
    for i : 1 .. 8
	if colorTemp = i then
	    result colorCirc (i)
	end if
    end for
end getColor

% Procedure for the game background
procedure gameBackground
    % Place where you select colours
    drawline (300, 570, 700, 570, black)

    drawLineX1 := 300
    drawLineX2 := 300
    for i : 1 .. 9
	drawline (drawLineX1, 570, drawLineX2, 620, black)
	drawLineX1 := drawLineX1 + 50
	drawLineX2 := drawLineX2 + 50
    end for

    % The circles at the top
    for i : 1 .. MAXCOLORNUM
	Draw.FillOval (topCircX, topCircY, 20, 20, colorCirc (i))
	topCircX := topCircX + 50
    end for
    topCircX := 325

    % Columns
    drawline (700, 520, 700, 20, black)
    drawline (650, 520, 650, 20, black)

    % Rows
    drawLineX1 := 650 - 50 * codeLength
    drawLineX2 := 700 + 25 * codeLength
    drawLineY1 := 520
    drawLineY2 := 520
    for i : 1 .. 11
	drawline (drawLineX1, drawLineY1, drawLineX2, drawLineY2, black)
	drawLineY1 := drawLineY1 - 50
	drawLineY2 := drawLineY2 - 50
    end for
end gameBackground

% Function that converts from string input answer to int
function answerIntStr (answerTempStr : string) : int
    for i : 1 .. MAXCOLORNUM
	if (answerTempStr = colorCharsList (i)) then
	    result i
	end if
    end for
end answerIntStr

% Loop for the entire program (With restart)
loop

    setscreen ("graphics:1000;620")

    % Loading screen
    cls
    Font.Draw ("LOADING", 300, 250, fontTitle, 7)

    Draw.ThickLine (300, 350, 300, 450, 5, black)
    Draw.ThickLine (300, 350, 730, 350, 5, black)
    Draw.ThickLine (300, 450, 730, 450, 5, black)
    Draw.ThickLine (730, 350, 730, 450, 5, black)

    loop
	Draw.FillBox (loadXOne, loadYOne, loadXTwo, loadYTwo, black)
	loadXOne := loadXTwo
	loadXTwo := loadXTwo + 1
	delay (3)

	exit when loadXTwo >= 730
    end loop

    %Resetting variables
    loadXOne := 300
    loadXTwo := 301

    cls

    % Menu
    % EXTENSION(Have graphics on the welcome and outcome screens)
    menu

    % Current option is 1
    Font.Draw (">>>", 150, 400, fontArrow, 7)

    menuInput := 1
    % Finding out the player option
    loop

	% Getting input from keyboard
	Input.KeyDown (chars)

	% Going up
	if chars (KEY_UP_ARROW) then
	    if (menuInput = 1) then
	    else
		menuInput := menuInput - 1
	    end if
	    menuArrow
	    delay (100)
	end if

	% Going down
	if chars (KEY_DOWN_ARROW) then
	    if (menuInput = 4) then
	    else
		menuInput := menuInput + 1
	    end if
	    menuArrow
	    delay (100)
	end if

	exit when chars (KEY_ENTER)
    end loop

    loop
	if (menuInput = ENTER_INSTRUCTIONS) then
	    % Goes to instructions then back to menu
	    cls
	    instructions

	    get inputAnyKey
	    cls
	    backToMenu := true
	elsif (menuInput = ENTER_STARTGAMEONEPLAYER) then
	    % Does not need to go to instructions, will continue to game
	    twoPlayer := false
	    backToMenu := false
	elsif (menuInput = ENTER_STARTGAMETWOPLAYER) then
	    % Does not need to go to instructions, will continue to game
	    twoPlayer := true
	    backToMenu := false
	elsif (menuInput = ENTER_OPTIONS) then
	    % Goes to options then back to menu
	    % EXTENSION(Allow user to set the number of guesses allowed)
	    cls
	    loop
		Font.Draw ("Number of Guesses:", 250, 400, fontEnd2, 7)
		locate (20, 62)
		get guessMaxNum
		exit when guessMaxNum > 0
		cls
	    end loop

	    % EXTENSION(User can set the length of the code)
	    cls
	    loop
		Font.Draw ("Code Length:", 330, 400, fontEnd2, 7)
		locate (20, 62)
		get codeLength
		exit when codeLength > 0
		cls
	    end loop

	    backToMenu := true
	end if

	exit when (backToMenu or backToMenu = false)
    end loop

    % Main game
    if (backToMenu = false) then

	var answer : array 1 .. codeLength of int
	var answerStr : array 1 .. codeLength of string
	var answerTaken : array 1 .. codeLength of boolean
	var guessTaken : array 1 .. codeLength of boolean
	var guess : array 1 .. codeLength of int
	var allColors : array 1 .. codeLength * guessMaxNum of int
	var allRightPos : array 1 .. guessMaxNum of int
	var allWrongPos : array 1 .. guessMaxNum of int

	% Resets variables
	for i : 1 .. codeLength
	    guess (i) := 0
	    answerTaken (i) := false
	    guessTaken (i) := false
	end for

	cls     % To start game (Game starts here)

	% Random code generation
	if (twoPlayer = false) then
	    for i : 1 .. codeLength
		randint (answer (i), MINCOLORNUM, MAXCOLORNUM)
	    end for
	else
	    % EXTENSION(Have a two-player version in which the secret code is entered by a player instead of randomly generated by the program. Code entered by the player must be validated)
	    for i : 1 .. codeLength
		loop
		    if (not (invalidInput)) then
			Font.Draw ("Enter Code", 300, 500, fontEnd2, black)
			Font.Draw (intstr (i), 700, 500, fontEnd2, black)
		    end if
		    twoPCircX := 220
		    twoPCircY := 250
		    for j : 1 .. MAXCOLORNUM
			Draw.FillOval (twoPCircX, twoPCircY, 30, 30, colorCirc (j))
			twoPCircX := twoPCircX + 80
		    end for
		    Font.Draw ("bl", 197, 150, fontEnd2, black)
		    Font.Draw ("gr", 272, 150, fontEnd2, black)
		    Font.Draw ("rd", 355, 150, fontEnd2, black)
		    Font.Draw ("pp", 430, 150, fontEnd2, black)
		    Font.Draw ("br", 513, 150, fontEnd2, black)
		    Font.Draw ("yl", 600, 150, fontEnd2, black)
		    Font.Draw ("mg", 665, 150, fontEnd2, black)
		    Font.Draw ("ga", 753, 150, fontEnd2, black)

		    locate (15, 62)
		    get answerStr (i)
		    cls
		    exit when (answerStr (i) = "bl" or answerStr (i) = "gr" or answerStr (i) = "rd" or answerStr (i) = "pp" or answerStr (i) = "br" or answerStr (i) = "yl" or answerStr (i) = "mg"
			or
			answerStr (i) = "ga")
		    invalidInput := true
		    cls
		    Font.Draw ("Invalid input! Type a color that is shown here!", 80, 500, fontGuess, black)
		end loop
		invalidInput := false
	    end for

	    % Converts from string input to int
	    for i : 1 .. codeLength
		answerTempStr := answerStr (i)
		answer (i) := answerIntStr (answerTempStr)
	    end for
	end if

	% Initializes the variables so that they have a value
	for i : 1 .. codeLength
	    answerTaken (i) := false
	    guessTaken (i) := false
	end for

	% Displays all the lines in ingame screen
	gameBackground

	% Guessing routine loop
	loop

	    currentRightCirc := guessNum - 9
	    currentWrongCirc := guessNum - 9

	    if (guessNum > MAXROW) then
		guessNumGraphicY := 28
		cls
		gameBackground

		% Scrolling circles after maxrow guessNum
		for i : 1 .. 9
		    for j : 1 .. codeLength
			guessCircX := 625 - 50 * (codeLength - j)
			guessCircY := 545 - 50 * i
			Draw.FillOval (guessCircX, guessCircY, 20, 20, allColors (i * codeLength - (codeLength - j) + (guessNum - MAXROW) * codeLength))
		    end for
		end for

		% Scrolling numbers after maxrow guessNum
		guessValue := intstr (guessNum)
		for i : 1 .. MAXROW
		    Font.Draw (guessValue, guessNumGraphicX, guessNumGraphicY, fontGuess, black)
		    guessValueInt := guessNum - i
		    guessValue := intstr (guessValueInt)
		    guessNumGraphicY := guessNumGraphicY + 50
		end for

		% Scrolling right and wrong output after maxrow guessNum
		for i : 1 .. 9
		    for j : 1 .. allRightPos (currentRightCirc)
			rightCircY := 557 - i * 50
			Draw.FillOval (rightCircX, rightCircY, 10, 10, red)
			rightCircX := rightCircX + 25
		    end for
		    currentRightCirc := currentRightCirc + 1
		    rightCircX := 712
		end for
		for i : 1 .. 9
		    for j : 1 .. allWrongPos (currentWrongCirc)
			wrongCircY := 532 - i * 50
			Draw.FillOval (wrongCircX, wrongCircY, 10, 10, blue)
			wrongCircX := wrongCircX + 25
		    end for
		    currentWrongCirc := currentWrongCirc + 1
		    wrongCircX := 712
		end for
	    end if

	    % Reset
	    rightCircX := 712
	    wrongCircX := 712

	    % Displays the guess number
	    if (guessNum <= MAXROW) then
		guessValue := intstr (guessNum)
		Font.Draw (guessValue, guessNumGraphicX, guessNumGraphicY, fontGuess, black)
		guessNumGraphicY := guessNumGraphicY - 50
	    end if

	    % Gets all guesses and displays them
	    % EXTENSION(Full graphical user interface: guesses are made using mouse click, guesses and feedbackare displayed graphically)
	    for i : 1 .. codeLength
		loop
		    buttonwait ("down", x, y, buttonnumber, buttonupdown)
		    guess (i) := getGuess (x, y)
		    exit when guess (i) > 0
		end loop

		colorTemp := guess (i)
		guessCircX := 625 - 50 * (codeLength - i)

		% Displays your guessed circles
		% EXTENSION(Guesses and feedback are displayed graphically)
		if (guessNum <= MAXROW) then
		    guessCircY := 545 - 50 * guessNum
		else
		    guessCircY := 545 - 50 * MAXROW
		end if

		Draw.FillOval (guessCircX, guessCircY, 20, 20, getColor (colorTemp))

		allColors (currentCircle) := getColor (colorTemp)
		currentCircle := currentCircle + 1
	    end for

	    % Loops and checks if all answers are right so far
	    for i : 1 .. codeLength
		if (guess (i) = answer (i)) then
		    guessRightSoFar := true
		else
		    guessRightSoFar := false
		    exit
		end if
	    end for

	    % If all answers are right, win. Else, continue with guessing and responding
	    if (guessRightSoFar) then
		youWin := true
		guessNum := guessMaxNum
	    else
		youWin := false
	    end if

	    if (youWin = false) then

		% Correct number correct position
		for i : 1 .. codeLength
		    if (answer (i) = guess (i)) then
			correctRightPosNum := correctRightPosNum + 1
			answerTaken (i) := true
			guessTaken (i) := true
		    end if
		end for

		% Correct number wrong position
		for i : 1 .. codeLength
		    if (guessTaken (i) = false) then
			for j : 1 .. codeLength
			    if (answerTaken (j) = false) then
				if (j not= i) then
				    if (guess (i) = answer (j)) then
					if (guessTaken (i) = false and answerTaken (j) = false) then
					    correctWrongPosNum := correctWrongPosNum + 1
					    answerTaken (j) := true
					    guessTaken (i) := true
					end if
				    end if
				end if
			    end if
			end for
		    end if
		end for

		allRightPos (guessNum) := correctRightPosNum
		allWrongPos (guessNum) := correctWrongPosNum

		% Displays the correct color and correct position and correct color and wrong position
		% EXTENSION(Guesses and feedback are displayed graphically)
		if (guessNum <= MAXROW) then
		    for i : 1 .. correctRightPosNum
			rightCircY := 557 - guessNum * 50
			Draw.FillOval (rightCircX, rightCircY, 10, 10, red)
			rightCircX := rightCircX + 25
		    end for
		    for i : 1 .. correctWrongPosNum
			wrongCircY := 532 - guessNum * 50
			Draw.FillOval (wrongCircX, wrongCircY, 10, 10, blue)
			wrongCircX := wrongCircX + 25
		    end for
		end if

	    end if

	    % Resetting the variables
	    for i : 1 .. codeLength
		guess (i) := 0
		answerTaken (i) := false
		guessTaken (i) := false
	    end for

	    correctRightPosNum := 0
	    correctWrongPosNum := 0

	    rightCircX := 712
	    wrongCircX := 712

	    % Counter
	    guessNum := guessNum + 1

	    exit when guessNum > guessMaxNum
	end loop

	% Ending screen
	% EXTENSION(Have graphics on the welcome and outcome screens)
	for decreasing i : 31 .. 16
	    endBackScreenColor := i
	    drawfillbox (0, 0, maxx, maxy, endBackScreenColor)
	    delay (50)
	end for

	if (youWin) then
	    if (twoPlayer = false) then
		for i : 16 .. 31
		    endTextColor := i
		    Font.Draw ("YOU WIN", 345, 310, fontEnd1, endTextColor)
		    delay (50)
		end for
	    else
		for i : 16 .. 31
		    endTextColor := i
		    Font.Draw ("PLAYER 1 WIN", 260, 310, fontEnd1, endTextColor)
		    delay (50)
		end for
	    end if
	else
	    if (twoPlayer = false) then
		for i : 16 .. 31
		    endTextColor := i
		    Font.Draw ("YOU LOSE: ALL GUESSES USED", 80, 400, fontEnd2, endTextColor)
		    delay (50)
		end for
	    else
		for i : 16 .. 31
		    endTextColor := i
		    Font.Draw ("PLAYER 2 WIN", 260, 400, fontEnd1, endTextColor)
		    delay (50)
		end for
	    end if
	    delay (1000)

	    for i : 16 .. 31
		endTextColor := i
		Font.Draw ("CODE: ", 330, 300, fontEnd3, endTextColor)
		delay (50)
	    end for

	    for i : 1 .. codeLength
		Draw.FillOval (codeEndX, 310, 20, 20, colorCirc (answer (i)))
		codeEndX := codeEndX + 50
		delay (500)
	    end for
	end if

	delay (2000)

	for i : 16 .. 31
	    endBackScreenColor := i
	    drawfillbox (0, 0, maxx, maxy, endBackScreenColor)
	    delay (50)
	end for

	% EXTENSION(Restart the game without restarting the program)
	endScreen
	Font.Draw (">>>", 150, 320, fontArrow, 7)

	% Finding out the player option
	loop

	    % Getting input from keyboard
	    Input.KeyDown (chars)

	    % Going up
	    if chars (KEY_UP_ARROW) then
		if (endInput = 1) then
		else
		    endInput := endInput - 1
		end if
		endArrow
		delay (100)
	    end if

	    % Going down
	    if chars (KEY_DOWN_ARROW) then
		if (endInput = 2) then
		else
		    endInput := endInput + 1
		end if
		endArrow
		delay (100)
	    end if

	    exit when chars (KEY_ENTER)
	end loop

	if (endInput = 1) then
	    endGame := false
	    cls
	else
	    endGame := true
	end if

	% Resetting variables
	menuInput := 1
	codeEndX := 510
	endInput := 1
	topCircX := 325
	guessCircY := 495
	guessNum := 1
	guessNumGraphicY := 478
	currentCircle := 1
	currentRightCirc := 2
	currentWrongCirc := 2

    end if
    exit when endGame
end loop

cls
