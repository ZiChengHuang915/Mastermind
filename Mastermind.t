/*
 File: Mastermind.t
 Name: ZiCheng Huang
 Class: ICS2O3
 Date: January 13, 2017
 Description: The game of mastermind. In this game, a code is randomly generated or it can be set by another player.
 The point of the game is to correctly guess the sequence of the code in a set amount of guesses. If you
 do, you win. Otherwise, you lose, or the other player wins. To help you, after every guess the computer
 will return the number of correct colors in the right position and also the number of correct colors in
 the wrong position.

 Extensions:
 -(Line 414)      Allow user to set the number of guesses allowed.
 -(Line 467)      Have a two-player version in which the secret code is entered by a player instead of randomly generated by the program. Code entered by the player must be validated.
 -(Line 737)      Restart the game without restarting the program.
 -(Line 344, 676) Have graphics on the welcome and outcome screens.
 -(Line 571, 640) Guesses and feedback are displayed graphically.
 -(Line 424)      User can set the length of the code.
 -(Line 559)      Full graphical user interface: guesses are made using mouse click, guesses and feedbackare displayed graphically.
 */

const ENTER_INSTRUCTIONS := 1
const ENTER_STARTGAMEONEPLAYER := 2
const ENTER_STARTGAMETWOPLAYER := 3
const ENTER_OPTIONS := 4

const RESTART := 1
const END_GAME := 2

const MAXROW := 10

var arrayIndex : int := 1

% Procedure for instructions
procedure instructions
    put "Rules of the game: \n"
    put "1 player:"
    put "The computer randomly generates a code, and you have to solve it in a certain number of guesses."
    put "In each guess, enter the colors that you think are correct, and the computer will give you feedback based on your guess."
    put "It will tell you the number of correct numbers in the right position."
    put "It will also tell you the number of correct numbers in the wrong position."
    put "You win if you guess the correct sequence of the code within the guesses allocated, and you will lose if you don't.\n"
    put "2 players:"
    put "The rules are the same, but the second player will put in his/her sequence instead of randomly generating it."
    put "Player 1 wins if he/she guesses the code within the guesses allocated, and Player 2 wins if he/she doesn't.\n"
    put "Press any key to continue!"
end instructions

% Menu variables


var chars : array char of boolean

var backToMenu : boolean := false
var menuInput : int := 0
var endInput : int := 1

var youWin : boolean := false
var endGame : boolean := false

var loadXOne : int := 300
var loadYOne : int := 350
var loadXTwo : int := 301
var loadYTwo : int := 450

var twoPCircX, twoPCircY : int
var invalidInput : boolean := false

% Gameplay variables (Do not reset!)
const MINCOLORNUM := 1
const MAXCOLORNUM := 8

var colorTemp : int

var colorCirc : array 1 .. 8 of int := init (1, 2, 4, 5, 185, 14, 13, 15)

var twoPlayer : boolean := false

var codeLength : int := 4 %User input optional

var guessNum : int := 1
var guessMaxNum : int := 12 %User input optional

% Gameplay variables (Reset every guess)
var guessRightSoFar : boolean := true

var correctRightPosNum : int := 0
var correctWrongPosNum : int := 0

% Fonts and graphical
var fontTitle : int := Font.New ("sans serif:72:bold")
var fontSub1 : int := Font.New ("Palatino:40:bold")
var fontSub2 : int := Font.New ("Palatino:30:bold")
var fontArrow : int := Font.New ("ar destine:40:bold")
var fontEnd1 : int := Font.New ("sans serif:50:bold")
var fontEnd2 : int := Font.New ("sans serif:40:bold")
var fontEnd3 : int := Font.New ("sans serif:30:bold")
var fontGuess : int := Font.New ("sans serif:30:bold")

var drawLineX1, drawLineX2 : int
var drawLineY1, drawLineY2 : int

var ballNum : int := Rand.Int (10, 30)
var ballX, ballY, ballColor, radius, updateX, updateY : array 1 .. ballNum of int
var isOutOfScreen : array 1 .. ballNum of boolean
var isAllOutOfScreen : boolean := false

% Ending screen variables
var codeEndX : int := 510
var endBackScreenColor : int
var endTextColor : int

% Procedure for ball graphic generation
procedure ballGen
    for i : 1 .. ballNum
	ballX (i) := Rand.Int (100, 900)
	ballY (i) := Rand.Int (100, 520)
	ballColor (i) := colorCirc (Rand.Int (MINCOLORNUM, MAXCOLORNUM))
	radius (i) := Rand.Int (15, 35)
	updateX (i) := Rand.Int (-2, 2)
	updateY (i) := Rand.Int (-2, 2)
	isOutOfScreen (i) := false
	loop
	    if (updateX (i) = 0) then
		updateX (i) := Rand.Int (-3, 3)
	    end if
	    exit when updateX (i) not= 0
	end loop
	loop
	    if (updateY (i) = 0) then
		updateY (i) := Rand.Int (-3, 3)
	    end if
	    exit when updateY (i) not= 0
	end loop
    end for
end ballGen

% Procedure for loading screen
procedure loadScreen
    ballGen

    View.Set ("offscreenonly")

    loop
	cls
	Font.Draw ("LOADING", 300, 250, fontTitle, 7)

	% Loading bar
	Draw.ThickLine (300, 350, 300, 450, 5, black)
	Draw.ThickLine (300, 350, 730, 350, 5, black)
	Draw.ThickLine (300, 450, 730, 450, 5, black)
	Draw.ThickLine (730, 350, 730, 450, 5, black)

	loadXOne := 300

	% Increasing bar
	Draw.FillBox (loadXOne, loadYOne, loadXTwo, loadYTwo, black)
	loadXTwo := loadXTwo + 1

	% When balls reaches edges, bounces back
	for i : 1 .. ballNum
	    if (ballX (i) < 0 + radius (i)) or (ballX (i) > 1000 - radius (i)) then
		updateX (i) := -updateX (i)
	    end if

	    if (ballY (i) < 0 + radius (i)) or (ballY (i) > 570 - radius (i)) then
		updateY (i) := -updateY (i)
	    end if

	    ballX (i) := ballX (i) + updateX (i)
	    ballY (i) := ballY (i) + updateY (i)

	    Draw.FillOval (ballX (i), ballY (i), radius (i), radius (i), ballColor (i))
	end for

	% Updates the balls
	View.Update
	delay (3)
	exit when loadXTwo >= 730
    end loop

    %Resetting variables
    loadXTwo := 301

    View.Update
    View.Set ("nooffscreenonly")
end loadScreen

% Procedure for menu screen
procedure menu
    Font.Draw ("MASTERMIND", 190, 500, fontTitle, 7)
    Font.Draw ("INSTRUCTIONS", 350, 400, fontSub2, 7)
    Font.Draw ("ONE PLAYER", 370, 300, fontSub2, 7)
    Font.Draw ("TWO PLAYER", 367, 200, fontSub2, 7)
    Font.Draw ("OPTIONS", 400, 100, fontSub2, 7)

    % Draws the ending positions of the balls
    for i : 1 .. ballNum
	Draw.FillOval (ballX (i), ballY (i), radius (i), radius (i), ballColor (i))
    end for
end menu

% Procedure for end screen
procedure endScreen
    Font.Draw ("MASTERMIND", 190, 500, fontTitle, 7)
    Font.Draw ("RESTART", 400, 320, fontSub2, 7)
    Font.Draw ("END GAME", 390, 220, fontSub2, 7)

    % Draws the ending positions of the balls
    for i : 1 .. ballNum
	Draw.FillOval (ballX (i), ballY (i), radius (i), radius (i), ballColor (i))
    end for
end endScreen

% Graphics for circles at the top
var topCircX : int := 325
var topCircY : int := 595

% Graphics for circles in main screen(displays guesses)
var guessCircX : int
var guessCircY : int := 495

var currentCircle : int := 1

% Displaying guess number
var guessNumGraphicX : int := 658
var guessNumGraphicY : int := 478
var guessValue : string
var guessValueInt : int

% Displaying correct position and color
var rightCircX : int := 712
var rightCircY : int := 557 - guessNum * 50
var wrongCircX : int := 712
var wrongCircY : int := 532 - guessNum * 50

var currentRightCirc : int := 2
var currentWrongCirc : int := 2

% Mouse stuff
var x, y, buttonnumber, buttonupdown, buttons : int

% Function for getting mouse input guess
function getGuess (x : int, y : int) : int
    for i : 1 .. 8
	if (x > 250 + i * 50 and x < 300 + i * 50 and y > 570 and y < 620) then
	    result i
	end if
    end for
    result 0
end getGuess

% Function for getting menu input
function getMenuInput (x : int, y : int) : int
    if (x >= 332 and x <= 676 and y >= 385 and y <= 448) then
	result 1
    elsif (x >= 332 and x <= 676 and y >= 280 and y <= 351) then
	result 2
    elsif (x >= 332 and x <= 676 and y >= 171 and y <= 259) then
	result 3
    elsif (x >= 332 and x <= 676 and y >= 82 and y <= 156) then
	result 4
    else
	result 0
    end if
end getMenuInput

% Function for getting end menu input
function getEndInput (x : int, y : int) : int
    if (x >= 354 and x <= 644 and y >= 295 and y <= 373) then
	result 1
    elsif (x >= 354 and x <= 644 and y >= 199 and y <= 278) then
	result 2
    else
	result 0
    end if
end getEndInput

% Function for getting circle colour
function getColor (colorTemp : int) : int
    for i : 1 .. 8
	if colorTemp = i then
	    result colorCirc (i)
	end if
    end for
end getColor

% Procedure for the game background
procedure gameBackground
    % Place where you select colours
    drawline (300, 570, 700, 570, black)

    drawLineX1 := 300
    drawLineX2 := 300
    for i : 1 .. 9
	drawline (drawLineX1, 570, drawLineX2, 620, black)
	drawLineX1 := drawLineX1 + 50
	drawLineX2 := drawLineX2 + 50
    end for

    % The circles at the top
    for i : 1 .. MAXCOLORNUM
	Draw.FillOval (topCircX, topCircY, 20, 20, colorCirc (i))
	topCircX := topCircX + 50
    end for
    topCircX := 325

    % Columns
    drawline (700, 520, 700, 20, black)
    drawline (650, 520, 650, 20, black)

    % Rows
    drawLineX1 := 650 - 50 * codeLength
    drawLineX2 := 700 + 25 * codeLength
    drawLineY1 := 520
    drawLineY2 := 520
    for i : 1 .. 11
	drawline (drawLineX1, drawLineY1, drawLineX2, drawLineY2, black)
	drawLineY1 := drawLineY1 - 50
	drawLineY2 := drawLineY2 - 50
    end for
end gameBackground

% Function that gets the answer in 2 player mode
function getAnswer (x : int, y : int) : int
    for i : 1 .. MAXCOLORNUM
	if (x >= 110 + i * 80 and x <= 170 + i * 80 and y >= 220 and y <= 280) then
	    result i
	end if
    end for
    result 0
end getAnswer

% Loop for the entire program (With restart)
loop

    setscreen ("graphics:1000;620")

    % Loading screen
    loadScreen
    cls

    % Menu
    % EXTENSION(Have graphics on the welcome and outcome screens)
    menu

    % Finding out the player option
    loop
	buttonwait ("down", x, y, buttonnumber, buttonupdown)
	menuInput := getMenuInput (x, y)
	exit when menuInput > 0
    end loop

    View.Set ("offscreenonly")

    loop
	cls
	for i : 1 .. ballNum

	    % Updates ball position
	    ballX (i) := ballX (i) + updateX (i)
	    ballY (i) := ballY (i) + updateY (i)
	    Draw.FillOval (ballX (i), ballY (i), radius (i), radius (i), ballColor (i))

	    % Checks if balls are out of screen
	    if (ballX (i) < 100 + radius (i)) or (ballX (i) > 900 - radius (i)) then
		if (ballY (i) < 100 + radius (i)) or (ballY (i) > 520 - radius (i)) then
		    isOutOfScreen (i) := true
		end if
	    end if
	end for
	menu
	View.Update
	delay (3)

	% Exits when all balls are out of screen
	arrayIndex := 1
	loop
	    if (isOutOfScreen (arrayIndex) = true) then
		isAllOutOfScreen := true
	    else
		isAllOutOfScreen := false
		exit
	    end if

	    exit when arrayIndex >= ballNum
	    arrayIndex := arrayIndex + 1
	end loop

	exit when isAllOutOfScreen = true
    end loop

    View.Set ("nooffscreenonly")

    loop
	if (menuInput = ENTER_INSTRUCTIONS) then
	    % Goes to instructions then back to menu
	    cls
	    instructions

	    Input.Pause
	    cls
	    backToMenu := true
	elsif (menuInput = ENTER_STARTGAMEONEPLAYER) then
	    % Does not need to go to instructions, will continue to game
	    twoPlayer := false
	    backToMenu := false
	elsif (menuInput = ENTER_STARTGAMETWOPLAYER) then
	    % Does not need to go to instructions, will continue to game
	    twoPlayer := true
	    backToMenu := false
	elsif (menuInput = ENTER_OPTIONS) then
	    % Goes to options then back to menu
	    % EXTENSION(Allow user to set the number of guesses allowed)
	    cls
	    loop
		Font.Draw ("Number of Guesses:", 250, 400, fontEnd2, 7)
		locate (20, 62)
		get guessMaxNum
		exit when guessMaxNum > 0
		cls
	    end loop

	    % EXTENSION(User can set the length of the code)
	    cls
	    loop
		Font.Draw ("Code Length:", 330, 400, fontEnd2, 7)
		locate (20, 62)
		get codeLength
		exit when codeLength > 0
		cls
	    end loop

	    backToMenu := true
	end if

	exit when (backToMenu or backToMenu = false)
    end loop

    % Main game
    if (backToMenu = false) then

	var answer : array 1 .. codeLength of int
	var answerStr : array 1 .. codeLength of string
	var answerTaken : array 1 .. codeLength of boolean
	var guessTaken : array 1 .. codeLength of boolean
	var guess : array 1 .. codeLength of int
	var allColors : array 1 .. codeLength * guessMaxNum of int
	var allRightPos : array 1 .. guessMaxNum of int
	var allWrongPos : array 1 .. guessMaxNum of int

	% Resets variables
	for i : 1 .. codeLength
	    guess (i) := 0
	    answerTaken (i) := false
	    guessTaken (i) := false
	end for

	cls     % To start game (Game starts here)

	% Random code generation
	if (twoPlayer = false) then
	    for i : 1 .. codeLength
		randint (answer (i), MINCOLORNUM, MAXCOLORNUM)
	    end for
	else
	    % EXTENSION(Have a two-player version in which the secret code is entered by a player instead of randomly generated by the program. Code entered by the player must be validated)
	    for i : 1 .. codeLength
		Font.Draw ("Choose Code:", 300, 500, fontEnd2, black)
		twoPCircX := 220
		twoPCircY := 250
		for j : 1 .. MAXCOLORNUM
		    Draw.FillOval (twoPCircX, twoPCircY, 30, 30, colorCirc (j))
		    twoPCircX := twoPCircX + 80
		end for

		% Waits for input
		loop
		    buttonwait ("down", x, y, buttonnumber, buttonupdown)
		    answer (i) := getAnswer (x, y)
		    exit when answer (i) > 0
		end loop
	    end for
	end if

	cls     % Screen refresh

	% Initializes the variables so that they have a value
	for i : 1 .. codeLength
	    answerTaken (i) := false
	    guessTaken (i) := false
	end for

	% Displays all the lines in ingame screen
	gameBackground

	% Guessing routine loop
	loop

	    currentRightCirc := guessNum - 9
	    currentWrongCirc := guessNum - 9

	    if (guessNum > MAXROW) then
		guessNumGraphicY := 28
		cls
		gameBackground

		% Scrolling circles after maxrow guessNum
		for i : 1 .. 9
		    for j : 1 .. codeLength
			guessCircX := 625 - 50 * (codeLength - j)
			guessCircY := 545 - 50 * i
			Draw.FillOval (guessCircX, guessCircY, 20, 20, allColors (i * codeLength - (codeLength - j) + (guessNum - MAXROW) * codeLength))
		    end for
		end for

		% Scrolling numbers after maxrow guessNum
		guessValue := intstr (guessNum)
		for i : 1 .. MAXROW
		    Font.Draw (guessValue, guessNumGraphicX, guessNumGraphicY, fontGuess, black)
		    guessValueInt := guessNum - i
		    guessValue := intstr (guessValueInt)
		    guessNumGraphicY := guessNumGraphicY + 50
		end for

		% Scrolling right and wrong output after maxrow guessNum
		for i : 1 .. 9
		    for j : 1 .. allRightPos (currentRightCirc)
			rightCircY := 557 - i * 50
			Draw.FillOval (rightCircX, rightCircY, 10, 10, red)
			rightCircX := rightCircX + 25
		    end for
		    currentRightCirc := currentRightCirc + 1
		    rightCircX := 712
		end for
		for i : 1 .. 9
		    for j : 1 .. allWrongPos (currentWrongCirc)
			wrongCircY := 532 - i * 50
			Draw.FillOval (wrongCircX, wrongCircY, 10, 10, blue)
			wrongCircX := wrongCircX + 25
		    end for
		    currentWrongCirc := currentWrongCirc + 1
		    wrongCircX := 712
		end for
	    end if

	    % Reset
	    rightCircX := 712
	    wrongCircX := 712

	    % Displays the guess number
	    if (guessNum <= MAXROW) then
		guessValue := intstr (guessNum)
		Font.Draw (guessValue, guessNumGraphicX, guessNumGraphicY, fontGuess, black)
		guessNumGraphicY := guessNumGraphicY - 50
	    end if

	    % Gets all guesses and displays them
	    % EXTENSION(Full graphical user interface: guesses are made using mouse click, guesses and feedbackare displayed graphically)
	    for i : 1 .. codeLength
		loop
		    buttonwait ("down", x, y, buttonnumber, buttonupdown)
		    guess (i) := getGuess (x, y)
		    exit when guess (i) > 0
		end loop

		colorTemp := guess (i)
		guessCircX := 625 - 50 * (codeLength - i)

		% Displays your guessed circles
		% EXTENSION(Guesses and feedback are displayed graphically)
		if (guessNum <= MAXROW) then
		    guessCircY := 545 - 50 * guessNum
		else
		    guessCircY := 545 - 50 * MAXROW
		end if

		Draw.FillOval (guessCircX, guessCircY, 20, 20, getColor (colorTemp))

		allColors (currentCircle) := getColor (colorTemp)
		currentCircle := currentCircle + 1
	    end for

	    % Loops and checks if all answers are right so far
	    arrayIndex := 1
	    loop
		if (guess (arrayIndex) = answer (arrayIndex)) then
		    guessRightSoFar := true
		else
		    guessRightSoFar := false
		    exit
		end if

		exit when arrayIndex >= codeLength
		arrayIndex := arrayIndex + 1
	    end loop

	    % If all answers are right, win. Else, continue with guessing and responding
	    if (guessRightSoFar) then
		youWin := true
		guessNum := guessMaxNum
	    else
		youWin := false
	    end if

	    if (youWin = false) then

		% Correct number correct position
		for i : 1 .. codeLength
		    if (answer (i) = guess (i)) then
			correctRightPosNum := correctRightPosNum + 1
			answerTaken (i) := true
			guessTaken (i) := true
		    end if
		end for

		% Correct number wrong position
		for i : 1 .. codeLength
		    if (guessTaken (i) = false) then
			for j : 1 .. codeLength
			    if (answerTaken (j) = false) then
				if (j not= i) then
				    if (guess (i) = answer (j)) then
					if (guessTaken (i) = false and answerTaken (j) = false) then
					    correctWrongPosNum := correctWrongPosNum + 1
					    answerTaken (j) := true
					    guessTaken (i) := true
					end if
				    end if
				end if
			    end if
			end for
		    end if
		end for

		allRightPos (guessNum) := correctRightPosNum
		allWrongPos (guessNum) := correctWrongPosNum

		% Displays the correct color and correct position and correct color and wrong position
		% EXTENSION(Guesses and feedback are displayed graphically)
		if (guessNum <= MAXROW) then
		    for i : 1 .. correctRightPosNum
			rightCircY := 557 - guessNum * 50
			Draw.FillOval (rightCircX, rightCircY, 10, 10, red)
			rightCircX := rightCircX + 25
		    end for
		    for i : 1 .. correctWrongPosNum
			wrongCircY := 532 - guessNum * 50
			Draw.FillOval (wrongCircX, wrongCircY, 10, 10, blue)
			wrongCircX := wrongCircX + 25
		    end for
		end if

	    end if

	    % Resetting the variables
	    for i : 1 .. codeLength
		guess (i) := 0
		answerTaken (i) := false
		guessTaken (i) := false
	    end for

	    correctRightPosNum := 0
	    correctWrongPosNum := 0

	    rightCircX := 712
	    wrongCircX := 712

	    % Counter
	    guessNum := guessNum + 1

	    exit when guessNum > guessMaxNum
	end loop

	% Ending screen
	% EXTENSION(Have graphics on the welcome and outcome screens)
	for decreasing i : 31 .. 16
	    endBackScreenColor := i
	    drawfillbox (0, 0, maxx, maxy, endBackScreenColor)
	    delay (50)
	end for

	% Displays different outcomes based on whether you win or not
	if (youWin) then
	    if (twoPlayer = false) then
		for i : 16 .. 31
		    endTextColor := i
		    Font.Draw ("YOU WIN", 345, 310, fontEnd1, endTextColor)
		    delay (50)
		end for
	    else
		for i : 16 .. 31
		    endTextColor := i
		    Font.Draw ("PLAYER 1 WIN", 260, 310, fontEnd1, endTextColor)
		    delay (50)
		end for
	    end if
	else
	    if (twoPlayer = false) then
		for i : 16 .. 31
		    endTextColor := i
		    Font.Draw ("YOU LOSE: ALL GUESSES USED", 80, 400, fontEnd2, endTextColor)
		    delay (50)
		end for
	    else
		for i : 16 .. 31
		    endTextColor := i
		    Font.Draw ("PLAYER 2 WIN", 260, 400, fontEnd1, endTextColor)
		    delay (50)
		end for
	    end if
	    delay (1000)

	    for i : 16 .. 31
		endTextColor := i
		Font.Draw ("CODE: ", 330, 300, fontEnd3, endTextColor)
		delay (50)
	    end for

	    % Displays correct code
	    for i : 1 .. codeLength
		Draw.FillOval (codeEndX, 310, 20, 20, colorCirc (answer (i)))
		codeEndX := codeEndX + 50
		delay (500)
	    end for
	end if

	delay (2000)

	% Fades to white
	for i : 16 .. 31
	    endBackScreenColor := i
	    drawfillbox (0, 0, maxx, maxy, endBackScreenColor)
	    delay (50)
	end for

	% EXTENSION(Restart the game without restarting the program)
	ballGen
	endScreen

	% Finding out the player option
	loop
	    buttonwait ("down", x, y, buttonnumber, buttonupdown)
	    endInput := getEndInput (x, y)
	    exit when endInput > 0
	end loop

	View.Set ("offscreenonly")

	loop
	    cls
	    for i : 1 .. ballNum

		% Updates ball position
		ballX (i) := ballX (i) + updateX (i)
		ballY (i) := ballY (i) + updateY (i)
		Draw.FillOval (ballX (i), ballY (i), radius (i), radius (i), ballColor (i))

		% Checks if balls are out of screen
		if (ballX (i) < 100 + radius (i)) or (ballX (i) > 900 - radius (i)) then
		    if (ballY (i) < 100 + radius (i)) or (ballY (i) > 520 - radius (i)) then
			isOutOfScreen (i) := true
		    end if
		end if
	    end for
	    endScreen
	    View.Update
	    delay (3)

	    % Exits when all balls are out of screen
	    arrayIndex := 1
	    loop
		if (isOutOfScreen (arrayIndex) = true) then
		    isAllOutOfScreen := true
		else
		    isAllOutOfScreen := false
		    exit
		end if

		exit when arrayIndex >= ballNum
		arrayIndex := arrayIndex + 1
	    end loop

	    exit when isAllOutOfScreen = true
	end loop

	View.Set ("nooffscreenonly")

	% Continues or quits based on player option
	if (endInput = 1) then
	    endGame := false
	    cls
	else
	    endGame := true
	end if

	% Resetting variables
	menuInput := 0
	codeEndX := 510
	endInput := 1
	topCircX := 325
	guessCircY := 495
	guessNum := 1
	guessNumGraphicY := 478
	currentCircle := 1
	currentRightCirc := 2
	currentWrongCirc := 2
	isAllOutOfScreen := false
	for i : 1 .. ballNum
	    isOutOfScreen (i) := false
	end for

    end if

    ballGen
    exit when endGame
end loop

cls
